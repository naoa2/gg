<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>新しいタブ</title>
    <link href="https://fonts.googleapis.com" rel="stylesheet">
    <style>
        :root {
            --blue: #00d2ff; --pink: #ff007f; --green: #0dff72; --yellow: #ffe138;
            --bg: #050508; --panel: rgba(255, 255, 255, 0.05); --text: #fff;
            --accent: var(--blue); --shadow: rgba(0, 210, 255, 0.5);
            --font-main: 'Orbitron', sans-serif;
        }

        .theme-darkness {
            --blue: #444; --pink: #ff1111; --green: #222; --bg: #000;
            --panel: #0a0a0a; --text: #888; --accent: #ff1111; --shadow: rgba(255, 0, 0, 0.3);
        }

        .theme-modern {
            --blue: #4a90e2; --pink: #f5a623; --green: #7ed321; --bg: #f4f7f6;
            --panel: #fff; --text: #333; --accent: #4a90e2; --shadow: rgba(74, 144, 226, 0.2);
            --font-main: 'Noto Sans JP', sans-serif;
        }

        body {
            background-color: var(--bg); color: var(--text);
            font-family: var(--font-main); margin: 0; overflow: hidden;
            transition: background 0.5s, color 0.5s;
        }

        /* --- UI ELEMENTS --- */
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .pointer { pointer-events: auto; }

        #menu {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; background: radial-gradient(circle at center, var(--panel) 0%, transparent 80%);
        }

        h1 {
            font-size: 5rem; font-weight: 900; letter-spacing: 15px; margin: 0;
            text-shadow: 0 0 30px var(--accent); color: var(--accent);
        }

        .btn-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-top: 40px; }
        .btn {
            padding: 20px 40px; font-size: 1.2rem; background: transparent;
            color: var(--text); border: 2px solid var(--accent); cursor: pointer;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: inherit; position: relative; overflow: hidden;
        }
        .btn:hover { background: var(--accent); color: var(--bg); box-shadow: 0 0 50px var(--accent); transform: scale(1.1); }

        #ranking-board {
            margin-top: 40px; width: 400px; background: var(--panel);
            padding: 20px; border-radius: 15px; border: 1px solid var(--accent);
        }
        .rank-item { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }

        /* --- GAME VIEW --- */
        #game-view { display: none; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        .stage-container { display: flex; gap: 40px; align-items: center; justify-content: center; }
        canvas { background: #000; border: 5px solid var(--accent); border-radius: 10px; box-shadow: 0 0 40px rgba(0,0,0,0.8); }
        .hud-bar { width: 80%; display: flex; justify-content: space-between; font-size: 2.5rem; margin-bottom: 20px; font-weight: 900; }

        /* --- MODALS --- */
        .modal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.98); border: 4px solid var(--green);
            padding: 40px; border-radius: 20px; z-index: 100; text-align: center;
        }
        .modal input { padding: 15px; font-size: 2rem; background: #000; color: #fff; border: 1px solid var(--green); text-align: center; width: 100px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="menu" class="pointer">
        <h1>ARCADE</h1>
        <div class="btn-grid">
            <button class="btn" onclick="Core.launch('tetris1')">1P TETRIS</button>
            <button class="btn" onclick="Core.launch('tetris2')">2P BATTLE</button>
            <button class="btn" onclick="UI.showTennis()">NEON TENNIS</button>
            <button class="btn" style="border-color:var(--pink)" onclick="Core.launch('survivor')">SURVIVOR</button>
        </div>
        <div style="margin-top:30px;">
            <button class="btn" style="padding:10px 20px; font-size:0.8rem;" onclick="UI.setTheme('neon')">NEON</button>
            <button class="btn" style="padding:10px 20px; font-size:0.8rem; border-color:#555;" onclick="UI.setTheme('darkness')">DARK</button>
            <button class="btn" style="padding:10px 20px; font-size:0.8rem; border-color:#4a90e2;" onclick="UI.setTheme('modern')">MODERN</button>
        </div>
        <div id="ranking-board">
            <h3 style="margin:0 0 10px 0; color:var(--accent)">TOP SCORES</h3>
            <div id="rank-content"></div>
        </div>
    </div>
</div>

<div id="game-view">
    <div class="hud-bar"><div id="hud-left"></div><div id="hud-right"></div></div>
    <div class="stage-container" id="stage"></div>
    <button class="btn pointer" style="margin-top:40px; border-color:var(--pink)" onclick="location.reload()">EXIT GAME</button>
</div>

<div id="modal-tennis" class="modal pointer">
    <h2 style="color:var(--blue)">TENNIS SETUP</h2>
    <p>TARGET SCORE</p>
    <input type="number" id="tennis-goal" value="5" min="1">
    <div class="btn-grid">
        <button class="btn" onclick="Core.launch('tennis-cpu')">vs CPU</button>
        <button class="btn" onclick="Core.launch('tennis-2p')">vs PLAYER</button>
    </div>
</div>

<div id="modal-skill" class="modal pointer">
    <h2 style="color:var(--green)">LEVEL UP!</h2>
    <div id="skill-list" class="btn-grid" style="grid-template-columns: 1fr;"></div>
</div>

<script>
/** 
 * CONSTANTS & DATA
 */
const SHAPES = [
    null,
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I
    [[2,0,0],[2,2,2],[0,0,0]], // L
    [[0,0,3],[3,3,3],[0,0,0]], // J
    [[4,4],[4,4]], // O
    [[5,5,0],[0,5,5],[0,0,0]], // Z
    [[0,6,6],[6,6,0],[0,0,0]], // S
    [[0,7,0],[7,7,7],[0,0,0]]  // T
];
const COLORS = [null, '#00d2ff', '#ff8e0d', '#3a47ff', '#ffe138', '#ff007f', '#0dff72', '#f538ff', '#777'];

/**
 * UI & ENGINE CORE
 */
const UI = {
    setTheme(t) { document.body.className = t==='neon'?'':'theme-'+t; localStorage.setItem('arc_th', t); },
    showTennis() { document.getElementById('modal-tennis').style.display = 'block'; },
    refreshRank() {
        const data = JSON.parse(localStorage.getItem('arc_ranks') || '[]');
        document.getElementById('rank-content').innerHTML = data.map((r,i)=>`
            <div class="rank-item"><span>${i+1}. ${r.name}</span><span>${r.score}</span></div>
        `).join('') || "NO DATA";
    }
};

const Core = {
    mode: '', instances: [], keys: {}, lastTime: 0,
    launch(m) {
        this.mode = m;
        document.getElementById('ui-layer').style.display = 'none';
        document.getElementById('modal-tennis').style.display = 'none';
        document.getElementById('game-view').style.display = 'flex';
        const stage = document.getElementById('stage'); stage.innerHTML = '';
        this.instances = [];
        this.lastTime = performance.now();

        if (m.startsWith('tetris')) {
            this.instances.push(new Tetris(stage, 0));
            if(m === 'tetris2') this.instances.push(new Tetris(stage, 1));
            requestAnimationFrame(t => this.tetrisLoop(t));
        } else if (m.startsWith('tennis')) {
            this.instances.push(new Tennis(stage, m==='tennis-2p'));
        } else if (m === 'survivor') {
            this.instances.push(new Survivor(stage));
        }
    },
    tetrisLoop(t) {
        if(!this.mode.startsWith('tetris')) return;
        const dt = t - this.lastTime; this.lastTime = t;
        this.instances.forEach(g => { g.update(dt); g.draw(); });
        document.getElementById('hud-left').innerText = `P1: ${this.instances[0].score}`;
        if(this.instances[1]) document.getElementById('hud-right').innerText = `P2: ${this.instances[1].score}`;
        requestAnimationFrame(t => this.tetrisLoop(t));
    },
    gameOver(s) {
        const name = prompt("GAME OVER! SCORE: " + s + "\nNAME:", "PLAYER") || "GUEST";
        let data = JSON.parse(localStorage.getItem('arc_ranks') || '[]');
        data.push({name, score: s});
        data.sort((a,b)=>b.score-a.score);
        localStorage.setItem('arc_ranks', JSON.stringify(data.slice(0,5)));
        location.reload();
    }
};

window.addEventListener('keydown', e => {
    Core.keys[e.code] = true;
    if(Core.mode.startsWith('tetris')) {
        Core.instances.forEach(g => {
            const isP1 = g.id === 0;
            const upKey = (isP1 ? (e.code==='KeyW' || (Core.instances.length===1 && e.code==='ArrowUp')) : (e.code==='ArrowUp'));
            if(upKey) g.rotate();
        });
    }
});
window.addEventListener('keyup', e => Core.keys[e.code] = false);

/**
 * TETRIS ENGINE
 */
class Tetris {
    constructor(con, id) {
        this.id = id; this.cvs = document.createElement('canvas'); this.cvs.width=280; this.cvs.height=560;
        con.appendChild(this.cvs); this.ctx = this.cvs.getContext('2d');
        this.grid = Array.from({length:20},()=>Array(10).fill(0));
        this.score = 0; this.dropCounter = 0; this.interval = 1000;
        this.spawn();
    }
    spawn() {
        this.matrix = JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random()*7)+1]));
        this.pos = {x:3, y:0};
        if(this.collide()) Core.gameOver(this.score);
    }
    collide() {
        for(let y=0; y<this.matrix.length; y++) for(let x=0; x<this.matrix[y].length; x++)
            if(this.matrix[y][x] && (this.grid[y+this.pos.y]?.[x+this.pos.x] !== 0)) return true;
        return false;
    }
    rotate() {
        const old = JSON.parse(JSON.stringify(this.matrix));
        this.matrix = this.matrix.map((_,i)=>this.matrix.map(r=>r[i]).reverse());
        if(this.collide()) this.matrix = old;
    }
    update(dt) {
        this.dropCounter += dt;
        if(this.dropCounter > this.interval) { this.drop(); this.dropCounter = 0; }
        const isP1 = this.id === 0;
        const isSingle = Core.instances.length === 1;

        if(isP1) {
            if(Core.keys['KeyA'] || (isSingle && Core.keys['ArrowLeft'])) { this.pos.x--; if(this.collide())this.pos.x++; Core.keys['KeyA']=Core.keys['ArrowLeft']=false; }
            if(Core.keys['KeyD'] || (isSingle && Core.keys['ArrowRight'])) { this.pos.x++; if(this.collide())this.pos.x--; Core.keys['KeyD']=Core.keys['ArrowRight']=false; }
            if(Core.keys['KeyS'] || (isSingle && Core.keys['ArrowDown'])) this.drop();
        } else {
            if(Core.keys['ArrowLeft']) { this.pos.x--; if(this.collide())this.pos.x++; Core.keys['ArrowLeft']=false; }
            if(Core.keys['ArrowRight']) { this.pos.x++; if(this.collide())this.pos.x--; Core.keys['ArrowRight']=false; }
            if(Core.keys['ArrowDown']) this.drop();
        }
    }
    drop() { this.pos.y++; if(this.collide()){ this.pos.y--; this.lock(); } }
    lock() {
        this.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) this.grid[y+this.pos.y][x+this.pos.x]=v; }));
        this.clearLines();
        this.spawn();
    }
    clearLines() {
        let rows = 0;
        for(let y=19; y>=0; y--) {
            if(this.grid[y].every(v => v !== 0 && v !== 8)) {
                this.grid.splice(y, 1);
                this.grid.unshift(Array(10).fill(0));
                rows++; y++;
            }
        }
        if(rows > 0) {
            this.score += [0, 100, 300, 500, 800][rows];
            if(rows >= 2 && Core.instances.length > 1) {
                const target = Core.instances[this.id===0?1:0];
                target.attack(rows - 1);
            }
        }
    }
    attack(n) {
        for(let i=0; i<n; i++) {
            const row = Array(10).fill(8);
            row[Math.floor(Math.random()*10)] = 0;
            this.grid.shift();
            this.grid.push(row);
        }
    }
    draw() {
        this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,280,560);
        this.grid.forEach((r,y)=>r.forEach((v,x)=>this.drawBlock(x,y,v)));
        this.matrix.forEach((r,y)=>r.forEach((v,x)=>this.drawBlock(x+this.pos.x, y+this.pos.y, v)));
    }
    drawBlock(x,y,v) {
        if(!v) return;
        this.ctx.fillStyle = COLORS[v];
        this.ctx.shadowBlur = 15; this.ctx.shadowColor = COLORS[v];
        this.ctx.fillRect(x*28, y*28, 27, 27);
        this.ctx.shadowBlur = 0;
    }
}

/**
 * TENNIS ENGINE
 */
class Tennis {
    constructor(con, is2p) {
        this.cvs = document.createElement('canvas'); this.cvs.width=800; this.cvs.height=500; con.appendChild(this.cvs);
        this.ctx = this.cvs.getContext('2d');
        this.is2p = is2p; this.goal = parseInt(document.getElementById('tennis-goal').value);
        this.p1=210; this.p2=210; this.s1=0; this.s2=0;
        this.ball={x:400,y:250,vx:6,vy:4};
        this.loop();
    }
    loop() {
        this.update(); this.draw();
        if(this.s1 < this.goal && this.s2 < this.goal) requestAnimationFrame(()=>this.loop());
        else Core.gameOver(Math.max(this.s1, this.s2)*100);
    }
    update() {
        if(Core.keys['KeyW'] || Core.keys['ArrowUp']) this.p1 -= 8;
        if(Core.keys['KeyS'] || Core.keys['ArrowDown']) this.p1 += 8;
        if(this.is2p) {
            if(Core.keys['KeyI']) this.p2 -= 8; if(Core.keys['KeyK']) this.p2 += 8;
        } else {
            this.p2 += (this.ball.y - (this.p2+40)) * 0.12;
        }
        this.p1 = Math.max(0, Math.min(420, this.p1));
        this.p2 = Math.max(0, Math.min(420, this.p2));

        this.ball.x += this.ball.vx; this.ball.y += this.ball.vy;
        if(this.ball.y < 0 || this.ball.y > 490) this.ball.vy *= -1;

        if(this.ball.x < 30 && this.ball.y > this.p1 && this.ball.y < this.p1+80) { this.ball.vx = Math.abs(this.ball.vx)*1.05; this.ball.x=31; }
        if(this.ball.x > 760 && this.ball.y > this.p2 && this.ball.y < this.p2+80) { this.ball.vx = -Math.abs(this.ball.vx)*1.05; this.ball.x=759; }

        if(this.ball.x < 0){ this.s2++; this.reset(); }
        if(this.ball.x > 800){ this.s1++; this.reset(); }
        document.getElementById('hud-left').innerText = `P1: ${this.s1}`;
        document.getElementById('hud-right').innerText = `P2: ${this.s2} (GOAL: ${this.goal})`;
    }
    reset() { this.ball = {x:400,y:250,vx:this.ball.vx>0?-6:6,vy:(Math.random()-0.5)*10}; }
    draw() {
        this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,800,500);
        this.ctx.fillStyle='#00d2ff'; this.ctx.fillRect(10,this.p1,15,80);
        this.ctx.fillStyle='#ff007f'; this.ctx.fillRect(775,this.p2,15,80);
        this.ctx.fillStyle='#fff'; this.ctx.shadowBlur=20; this.ctx.shadowColor='#fff';
        this.ctx.fillRect(this.ball.x,this.ball.y,12,12);
        this.ctx.shadowBlur=0;
    }
}

/**
 * SURVIVOR ENGINE
 */
class Survivor {
    constructor(con) {
        this.cvs = document.createElement('canvas'); this.cvs.width=900; this.cvs.height=600; con.appendChild(this.cvs);
        this.ctx = this.cvs.getContext('2d');
        this.p = {x:450,y:300,hp:100,lv:1,exp:0,nx:5,spd:5,bc:1,dmg:1};
        this.en=[]; this.bl=[]; this.gm=[]; this.paused=false; this.score=0; this.lastShot=0;
        this.itv = setInterval(()=>this.spawn(), 1000);
        this.loop(0);
    }
    spawn() { if(!this.paused) this.en.push({x:Math.random()*900,y:Math.random()>0.5?-30:630,hp:this.p.lv}); }
    loop(t) {
        if(this.paused) { requestAnimationFrame(tt=>this.loop(tt)); return; }
        this.update(t); this.draw();
        if(this.p.hp > 0) requestAnimationFrame(tt=>this.loop(tt));
        else { clearInterval(this.itv); Core.gameOver(this.score); }
    }
    update(t) {
        const p = this.p;
        if(Core.keys['KeyW']||Core.keys['ArrowUp']) p.y -= p.spd; if(Core.keys['KeyS']||Core.keys['ArrowDown']) p.y += p.spd;
        if(Core.keys['KeyA']||Core.keys['ArrowLeft']) p.x -= p.spd; if(Core.keys['KeyD']||Core.keys['ArrowRight']) p.x += p.spd;

        if(t - this.lastShot > 500 && this.en.length) {
            const target = this.en[0]; const a = Math.atan2(target.y-p.y, target.x-p.x);
            for(let i=0; i<p.bc; i++) this.bl.push({x:p.x,y:p.y,vx:Math.cos(a+(i*0.2-0.1))*10,vy:Math.sin(a+(i*0.2-0.1))*10});
            this.lastShot = t;
        }

        this.bl.forEach((b,i)=>{
            b.x+=b.vx; b.y+=b.vy;
            this.en.forEach((e,ei)=>{
                if(Math.hypot(e.x-b.x,e.y-b.y)<25) {
                    e.hp -= p.dmg; this.bl.splice(i,1);
                    if(e.hp<=0){ this.gm.push({x:e.x,y:e.y}); this.en.splice(ei,1); this.score+=10; }
                }
            });
        });
        this.en.forEach(e=>{
            const a=Math.atan2(p.y-e.y,p.x-e.x); e.x+=Math.cos(a)*2; e.y+=Math.sin(a)*2;
            if(Math.hypot(p.x-e.x,p.y-e.y)<20) p.hp-=0.25;
        });
        this.gm.forEach((g,i)=>{
            if(Math.hypot(p.x-g.x,p.y-g.y)<30){ this.gm.splice(i,1); p.exp++; if(p.exp>=p.nx)this.lvUp(); }
        });
        document.getElementById('hud-left').innerText = `SCORE: ${this.score}`;
        document.getElementById('hud-right').innerText = `HP: ${Math.ceil(p.hp)}% | LV: ${p.lv}`;
    }
    lvUp() {
        this.paused = true; const m = document.getElementById('modal-skill'); const l = document.getElementById('skill-list');
        m.style.display='block'; l.innerHTML='';
        ['EXTRA BULLET','FASTER MOVE','HP & POWER UP'].forEach(s=>{
            const b = document.createElement('button'); b.className='btn'; b.innerText=s;
            b.onclick=()=>{
                if(s.includes('BULLET')) this.p.bc++; if(s.includes('MOVE')) this.p.spd+=1;
                if(s.includes('POWER')) { this.p.dmg++; this.p.hp=100; }
                this.p.exp=0; this.p.nx=Math.floor(this.p.nx*1.6); this.p.lv++;
                m.style.display='none'; this.paused=false;
            }; l.appendChild(b);
        });
    }
    draw() {
        this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,900,600);
        this.gm.forEach(g=>{ this.ctx.fillStyle='#00d2ff'; this.ctx.shadowBlur=10; this.ctx.fillRect(g.x,g.y,8,8); });
        this.en.forEach(e=>{ this.ctx.fillStyle='#ff007f'; this.ctx.beginPath(); this.ctx.arc(e.x,e.y,12,0,7); this.ctx.fill(); });
        this.bl.forEach(b=>{ this.ctx.fillStyle='#fff'; this.ctx.shadowBlur=15; this.ctx.fillRect(b.x,b.y,6,6); });
        this.ctx.shadowBlur=20; this.ctx.shadowColor='#0dff72'; this.ctx.fillStyle='#0dff72';
        this.ctx.beginPath(); this.ctx.arc(this.p.x,this.p.y,15,0,7); this.ctx.fill();
        this.ctx.shadowBlur=0;
    }
}

UI.refreshRank(); UI.setTheme(localStorage.getItem('arc_th')||'neon');
        const coverHtml = `
    <div id="cover-layer" style="position:fixed; top:0; left:0; width:100%; height:100%; background:#ffffff; color:#333; z-index:99999; display:flex; flex-direction:column; align-items:center; justify-content:center; font-family:sans-serif; pointer-events:all;">
        <div style="text-align:center; border:1px solid #ddd; padding:50px; border-radius:8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <h2 style="color:#666; font-size:1rem; margin-bottom:20px;">計算トレーニング：無限モード</h2>
            <div id="calc-q" style="font-size:3.5rem; font-weight:bold; margin-bottom:30px; letter-spacing:2px; color:#000;">--- + ---</div>
            <input type="number" id="calc-a" style="font-size:2rem; width:220px; padding:10px; border:2px solid #4a90e2; border-radius:5px; text-align:center;" placeholder="答えを入力" autofocus>
            <p style="margin-top:20px; color:#999; font-size:0.8rem;">[Enter]で次の問題へ</p>
        </div>
    </div>`;
    document.body.insertAdjacentHTML('beforeend', coverHtml);

    const nextQ = () => {
        document.getElementById('calc-q').innerText = `${Math.floor(Math.random()*900+100)} + ${Math.floor(Math.random()*900+100)}`;
        document.getElementById('calc-a').value = "";
    };
    
    document.getElementById('calc-a').addEventListener('keydown', (e) => { if(e.key === 'Enter') nextQ(); });
    nextQ();

    window.addEventListener('keydown', (e) => {
        if (e.ctrlKey && (e.key === "@" || e.code === "Digit2" || e.key === "`")) {
            if (prompt("認証パスワードを入力してください") === "asdfghjk") {
                document.getElementById('cover-layer').style.display = "none";
            }
        }
    });
</script>
</body>
</html>
